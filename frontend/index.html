<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Storm Dennis & Ciara - Wind Turbine SCADA</title>
  <style>
    body { font-family: system-ui, -apple-system, 'Segoe UI', Roboto, Arial; background:#f7fafc; color:#0f172a; padding:20px }
    /* visually indicate disabled turbine buttons */
    button[disabled] { opacity: 0.5; cursor: not-allowed; }
    .grid { display:grid; grid-template-columns:repeat(2, 1fr); gap:16px; max-width:1200px; margin:0 auto }
    .card { background:#fff; border-radius:10px; padding:14px; box-shadow:0 4px 18px rgba(2,6,23,0.06) }
    h2 { margin:0 0 8px; font-size:16px }
    .meta { color:#6b7280; font-size:13px; margin-bottom:8px }
    .small { color:#6b7280; font-size:12px }
    .param { font-size:14px; margin:6px 0 }
    .wind-bar { height:12px; background:#eef6ff; border-radius:6px; overflow:hidden; margin-top:8px }
    .wind-bar-inner { height:100%; background:linear-gradient(90deg,#60a5fa,#2563eb); width:0%; transition:width 0.5s ease }
    .dir-row { display:flex; gap:12px; margin-top:8px; align-items:center }
    .dir-cell { text-align:center }
    .panel-footer { margin-top:10px; font-size:12px; color:#6b7280 }
    .controls { display:flex; gap:8px; align-items:center; margin-top:6px }
    input[type=number] { width:100px; padding:6px; border-radius:6px; border:1px solid #e5e7eb }
    button { padding:6px 10px; border-radius:6px; border:1px solid #e5e7eb; background:#fff }
    .badge { display:inline-block; padding:4px 8px; border-radius:6px; color:white; font-size:12px; font-weight:600 }
    .badge-info { background:#2563eb } /* blue */
    .badge-warning { background:#f59e0b; color:#111827 } /* yellow */
    .badge-stop { background:#ef4444 } /* red */
    .badge-default { background:#6b7280 } /* gray */
    /* Toggle buttons */
    .toggle-group { display:flex; gap:8px; justify-content:center; margin-bottom:12px }
    .toggle-btn { padding:8px 12px; border-radius:8px; border:1px solid #e5e7eb; cursor:pointer; background:#fff }
    .toggle-btn.active { background:#2563eb; color:#fff; border-color:#1e40af }
    /* small spinner used when waiting for data after changing date */
    .spinner { border:3px solid #f3f4f6; border-top:3px solid #2563eb; border-radius:50%; width:18px; height:18px; animation:spin 1s linear infinite; display:inline-block }
    @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
  </style>
</head>
<body>
  <h1 style="text-align:center; margin-bottom:18px">ðŸŒ€ Storm Dennis & Ciara - February 2020</h1>
  <div id="app">
    <!-- site toggle buttons -->
    <div class="toggle-group">
      <button :class="['toggle-btn', activeSite === 'kelmarsh' ? 'active' : '']" @click="setSite('kelmarsh')">Kelmarsh</button>
      <button :class="['toggle-btn', activeSite === 'penmanshiel' ? 'active' : '']" @click="setSite('penmanshiel')">Penmanshiel</button>
    </div>

    <!-- All Turbines Data + Status View -->
    <div id="turbine-view-section" style="max-width:1200px; margin:10px auto 18px;">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px; flex-wrap:wrap; gap:10px;">
        <div style="font-weight:700;">{{ activeSite === 'kelmarsh' ? 'Kelmarsh' : 'Penmanshiel' }} Wind Farm - Live SCADA Replay</div>

        <!-- Date picker -->
        <div style="display:flex; align-items:center; gap:8px;">
          <label style="font-size:13px; display:flex; align-items:center; gap:6px;">
            Start from:
            <input type="date"
                   :value="siteStartDates[activeSite]"
                   :min="availableDates[activeSite]?.min_date"
                   :max="availableDates[activeSite]?.max_date"
                   @change="onDateChange($event)"
                   style="padding:4px 8px; border:1px solid #e5e7eb; border-radius:4px;" />
          </label>
          <button v-if="siteStartDates[activeSite]"
                  class="toggle-btn"
                  @click="clearStartDate()"
                  style="padding:4px 8px; font-size:12px;">
            Reset
          </button>
          <span v-if="dateLoading" class="spinner" style="width:14px; height:14px;"></span>
        </div>
      </div>

      <!-- Grid showing turbines (6 for Kelmarsh, 15 for Penmanshiel but skip 3) -->
      <div style="display:grid; grid-template-columns:repeat(3, 1fr); gap:12px;">
        <div v-for="t in turbineRange" :key="'turbine-'+t" class="card" style="padding:12px;">
          <h2 style="margin:0 0 10px; font-size:15px; text-align:center; border-bottom:1px solid #e5e7eb; padding-bottom:8px;">Turbine {{ t }}</h2>

          <!-- Data section -->
          <div style="margin-bottom:10px;">
            <div style="font-weight:600; font-size:13px; margin-bottom:6px; color:#2563eb;">Data</div>
            <div style="display:flex; gap:8px; justify-content:center; align-items:center;">
              <!-- Nacelle SVG -->
              <div style="text-align:center; width:60px;">
                <svg viewBox="0 0 100 100" width="50" height="50" aria-hidden="true">
                  <circle cx="50" cy="50" r="38" stroke="#e6eef8" fill="#fff" stroke-width="3" />
                  <g :transform="'rotate(' + (turbineData[t] && turbineData[t].nacelle || 0) + ' 50 50)'">
                    <line x1="50" y1="50" x2="50" y2="14" stroke="#84cc16" stroke-width="3" stroke-linecap="round" />
                    <circle cx="50" cy="50" r="3" fill="#84cc16" />
                  </g>
                </svg>
                <div class="small">Nac: <strong>{{ turbineData[t] && turbineData[t].nacelle != null ? turbineData[t].nacelle + 'Â°' : 'â€”' }}</strong></div>
              </div>

              <!-- Wind SVG -->
              <div style="text-align:center; width:60px;">
                <svg viewBox="0 0 100 100" width="50" height="50" aria-hidden="true">
                  <circle cx="50" cy="50" r="38" stroke="#eef6ff" fill="#fff" stroke-width="3" />
                  <g :transform="'rotate(' + (turbineData[t] && turbineData[t].wind || 0) + ' 50 50)'">
                    <line x1="50" y1="50" x2="50" y2="10" stroke="#0369a1" stroke-width="3" stroke-linecap="round" />
                    <circle cx="50" cy="50" r="3" fill="#0369a1" />
                  </g>
                </svg>
                <div class="small">Wind: <strong>{{ turbineData[t] && turbineData[t].wind != null ? turbineData[t].wind + 'Â°' : 'â€”' }}</strong></div>
              </div>
            </div>

            <!-- Wind Speed with visual bar -->
            <div style="margin-top:8px; padding:0 8px;">
              <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:2px;">
                <span class="small" style="color:#0369a1;">ðŸ’¨ Speed</span>
                <span class="small"><strong>{{ turbineData[t] && turbineData[t].windSpeed != null ? turbineData[t].windSpeed.toFixed(1) + ' m/s' : 'â€”' }}</strong></span>
              </div>
              <div style="height:8px; background:#e5e7eb; border-radius:4px; overflow:hidden;">
                <div :style="{
                  width: (Math.min(Math.max(turbineData[t] && turbineData[t].windSpeed || 0, 0), 25) / 25 * 100) + '%',
                  height: '100%',
                  background: (turbineData[t] && turbineData[t].windSpeed != null)
                    ? (turbineData[t].windSpeed < 5 ? '#22c55e' : turbineData[t].windSpeed < 12 ? '#3b82f6' : turbineData[t].windSpeed < 20 ? '#f59e0b' : '#ef4444')
                    : '#9ca3af',
                  transition: 'width 0.3s ease, background 0.3s ease',
                  borderRadius: '4px'
                }"></div>
              </div>
            </div>

            <div class="small" style="text-align:center; margin-top:6px; font-size:10px;">
              {{ turbineData[t] && turbineData[t].ts ? new Date(turbineData[t].ts).toLocaleString() : 'â€”' }}
            </div>
          </div>

          <!-- Status section -->
          <div style="border-top:1px solid #e5e7eb; padding-top:8px;">
            <div style="font-weight:600; font-size:13px; margin-bottom:4px; color:#ef4444;">Status</div>
            <div class="small" style="margin-bottom:2px;">
              <strong>Time:</strong> {{ turbineStatus[t] && turbineStatus[t].timestampStart || 'â€”' }}
            </div>
            <div class="small" style="margin-bottom:2px;">
              <strong>End:</strong> {{ turbineStatus[t] && turbineStatus[t].timestampEnd || 'â€”' }}
            </div>
            <div class="small" style="margin-bottom:2px;">
              <strong>Duration:</strong> {{ turbineStatus[t] && turbineStatus[t].duration || 'â€”' }}
            </div>
            <div class="small" style="word-break:break-word;">
              <strong>Msg:</strong> {{ turbineStatus[t] && turbineStatus[t].message || 'â€”' }}
            </div>
          </div>
        </div>
      </div>
    </div>


  </div> <!-- end #app -->

  <script src="https://cdn.jsdelivr.net/npm/vue@3/dist/vue.global.prod.js"></script>
  <script>if(typeof Vue === 'undefined'){ console.error('Vue failed to load - check network or CDN.'); document.body.insertAdjacentHTML('afterbegin', '<div style="background:#fee; color:#900; padding:8px; text-align:center">Vue failed to load - check network or CDN.</div>'); }</script>
  <script>
    const { createApp, reactive, ref, onMounted, onBeforeUnmount, computed } = Vue;

    createApp({
      setup() {
        const panelList = [
          { key: 'penmanshiel_data', title: 'Penmanshiel Data', path: '/sse/next-record', byTurbine: '/sse/by-turbine/penmanshiel_data', minT: 1, maxT: 15 },
          { key: 'penmanshiel_all_status', title: 'Penmanshiel Status', path: '/sse/penmanshiel_all_status', byTurbine: '/sse/by-turbine/penmanshiel_status', minT: 1, maxT: 15 }
        ];

        const panels = reactive({
          penmanshiel_data: { es: null, connected: false, lastRowid: null, display: [], windSpeed: null, windDir: null, nacelleDir: null, waitSeconds: 1, statusValue: null, statusClass: 'badge-default', loading: false, turbine: null, reconnectTimer: null },
          penmanshiel_all_status: { es: null, connected: false, lastRowid: null, display: [], windSpeed: null, windDir: null, nacelleDir: null, waitSeconds: 1, statusValue: null, statusClass: 'badge-default', loading: false, turbine: null, reconnectTimer: null }
        });

        // All turbines data - separate stores for each site (run in background)
        const kelmarshData = reactive({});  // keys: turbine number -> { nacelle, wind, windSpeed, ts }
        const kelmarshStatus = reactive({}); // keys: turbine number -> { timestampStart, timestampEnd, message, duration }
        const penmanshielData = reactive({});
        const penmanshielStatus = reactive({});

        // Computed references to currently displayed site's data
        const turbineData = computed(() => activeSite.value === 'kelmarsh' ? kelmarshData : penmanshielData);
        const turbineStatus = computed(() => activeSite.value === 'kelmarsh' ? kelmarshStatus : penmanshielStatus);

        // Date picker state
        const siteStartDates = reactive({ kelmarsh: null, penmanshiel: null });
        const availableDates = reactive({ kelmarsh: null, penmanshiel: null });
        const dateLoading = ref(false);

        // Fetch available dates for both sites on startup
        async function fetchAvailableDates(site) {
          try {
            const base = (location.origin === 'null' ? 'http://127.0.0.1:8000' : location.origin);
            const response = await fetch(`${base}/api/available-dates/${site}`);
            const data = await response.json();
            if (data && data.dates) {
              availableDates[site] = data;
            }
          } catch (err) {
            console.error('Failed to fetch available dates for', site, err);
          }
        }

        // EventSources for each site (both run simultaneously)
        let kelmarshES = null;
        let kelmarshReconnect = null;
        let penmanshielES = null;
        let penmanshielReconnect = null;

        // activeSite controls which wind farm is displayed
        const activeSite = ref('kelmarsh');

        // Computed turbine range based on active site
        const turbineRange = computed(() => {
          if (activeSite.value === 'kelmarsh') {
            return [1, 2, 3, 4, 5, 6];
          } else {
            // Penmanshiel: 1-15 but skip turbine 3 (no data)
            return [1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];
          }
        });

        function buildUrl(path, waitSeconds) {
          const base = (location.origin === 'null' ? 'http://127.0.0.1:8000' : location.origin);
          const u = new URL(path, base);
          if (waitSeconds !== undefined && waitSeconds !== null) u.searchParams.set('wait_seconds', String(waitSeconds));
          return u;
        }


        function startSiteStream(site) {
          const dataStore = site === 'kelmarsh' ? kelmarshData : penmanshielData;
          const statusStore = site === 'kelmarsh' ? kelmarshStatus : penmanshielStatus;
          const startDate = siteStartDates[site];

          // Get/set the right ES and reconnect timer
          let es = site === 'kelmarsh' ? kelmarshES : penmanshielES;
          let reconnectTimer = site === 'kelmarsh' ? kelmarshReconnect : penmanshielReconnect;

          // Close existing stream for this site
          try { if (es) es.close(); } catch(_){}
          try { if (reconnectTimer) clearTimeout(reconnectTimer); } catch(_){}

          // Clear existing data for this site
          const turbineList = site === 'kelmarsh' ? [1,2,3,4,5,6] : [1,2,4,5,6,7,8,9,10,11,12,13,14,15];
          for (const t of turbineList) {
            delete dataStore[t];
            delete statusStore[t];
          }

          // Build URL - use date-specific endpoint if start date is set
          let url;
          if (startDate) {
            url = buildUrl('/sse/all-turbines/' + site + '/from/' + startDate, 1);
          } else {
            url = buildUrl('/sse/all-turbines/' + site, 1);
          }
          es = new EventSource(url.toString());

          // Store reference
          if (site === 'kelmarsh') kelmarshES = es;
          else penmanshielES = es;

          es.onmessage = (ev) => {
            try {
              const obj = JSON.parse(ev.data);
              if (obj && obj.turbines) {
                for (const [turbineStr, tData] of Object.entries(obj.turbines)) {
                  const turbine = parseInt(turbineStr);

                  // Parse data record
                  if (tData && tData.data && tData.data.record) {
                    const rec = tData.data.record;
                    const nacKey = Object.keys(rec).find(k => k && k.toLowerCase().includes('nacelle'));
                    const wdKey = Object.keys(rec).find(k => k && (k.toLowerCase().includes('wind direction') || k.toLowerCase().includes('wind dir')));
                    const nacelle = nacKey ? Math.round(parseFloat(String(rec[nacKey]).replace(/[^0-9.+-eE]/g,''))) : null;
                    const wind = wdKey ? Math.round(parseFloat(String(rec[wdKey]).replace(/[^0-9.+-eE]/g,''))) : null;
                    const wsKey = Object.keys(rec).find(k => k && (k.toLowerCase().includes('wind speed') || k.toLowerCase() === 'ws'));
                    const windSpeed = wsKey ? parseFloat(String(rec[wsKey]).replace(/[^0-9.+-eE]/g,'')) : null;
                    const tsKey = Object.keys(rec).find(k => /timestamp|datetime|date|time/i.test(k));
                    const ts = tsKey && rec[tsKey] ? Date.parse(rec[tsKey]) : Date.now();
                    dataStore[turbine] = { nacelle, wind, windSpeed, ts };
                  }

                  // Parse status record
                  if (tData && tData.status && tData.status.record) {
                    const rec = tData.status.record;
                    const tsKey = Object.keys(rec).find(k => k && k.toLowerCase().includes('timestamp start')) ||
                                  Object.keys(rec).find(k => /timestamp|datetime|date|time/i.test(k));
                    const timestampStart = tsKey && rec[tsKey] ? rec[tsKey] : null;
                    const tsEndKey = Object.keys(rec).find(k => k && k.toLowerCase().includes('timestamp end'));
                    const timestampEnd = tsEndKey && rec[tsEndKey] ? rec[tsEndKey] : null;
                    const msgKey = Object.keys(rec).find(k => k && k.toLowerCase() === 'message');
                    const message = msgKey && rec[msgKey] ? rec[msgKey] : null;
                    const durKey = Object.keys(rec).find(k => k && k.toLowerCase() === 'duration');
                    const duration = durKey && rec[durKey] ? rec[durKey] : null;
                    statusStore[turbine] = { timestampStart, timestampEnd, message, duration };
                  }
                }
              }
            } catch (err) { console.error(site + ' stream parse error', err); }
          };

          es.onerror = () => {
            console.error(site + ' stream error, reconnecting...');
            const timer = setTimeout(() => startSiteStream(site), 2000);
            if (site === 'kelmarsh') kelmarshReconnect = timer;
            else penmanshielReconnect = timer;
          };
        }

        function startAllStreams() {
          // Fetch available dates first
          fetchAvailableDates('kelmarsh');
          fetchAvailableDates('penmanshiel');

          // Start both site streams simultaneously
          startSiteStream('kelmarsh');
          startSiteStream('penmanshiel');
        }

        function stopAllStreams() {
          // Stop Kelmarsh stream
          try { if (kelmarshES) kelmarshES.close(); } catch(_){}
          try { if (kelmarshReconnect) clearTimeout(kelmarshReconnect); } catch(_){}
          kelmarshES = null;

          // Stop Penmanshiel stream
          try { if (penmanshielES) penmanshielES.close(); } catch(_){}
          try { if (penmanshielReconnect) clearTimeout(penmanshielReconnect); } catch(_){}
          penmanshielES = null;
        }

        function setSite(name) {
          if (name !== 'kelmarsh' && name !== 'penmanshiel') return;
          // Just switch the view - streams continue running in background
          activeSite.value = name;
        }

        function onDateChange(event) {
          const site = activeSite.value;
          const newDate = event.target.value;

          if (newDate) {
            // Validate that date is in available dates
            const available = availableDates[site];
            if (available && available.dates && !available.dates.includes(newDate)) {
              // Find closest available date
              const closest = available.dates.reduce((prev, curr) => {
                return Math.abs(new Date(curr) - new Date(newDate)) < Math.abs(new Date(prev) - new Date(newDate)) ? curr : prev;
              });
              siteStartDates[site] = closest;
            } else {
              siteStartDates[site] = newDate;
            }
          } else {
            siteStartDates[site] = null;
          }

          dateLoading.value = true;
          // Restart stream for this site with new date
          startSiteStream(site);
          setTimeout(() => { dateLoading.value = false; }, 1000);
        }

        function clearStartDate() {
          const site = activeSite.value;
          siteStartDates[site] = null;
          dateLoading.value = true;
          startSiteStream(site);
          setTimeout(() => { dateLoading.value = false; }, 1000);
        }

        // Start both site streams on init
        startAllStreams();

        // per-panel-type selected start dates (YYYY-MM-DD) â€” null means no filtering
        const siteDates = reactive({ kelmarsh_status: null, penmanshiel_data: null, penmanshiel_status: null });

        function formatDateLocalYYYYMMDD(ms) {
          const d = new Date(ms);
          const y = d.getFullYear();
          const m = String(d.getMonth() + 1).padStart(2, '0');
          const day = String(d.getDate()).padStart(2, '0');
          return `${y}-${m}-${day}`;
        }

        function applyDate(site, type) {
          // clear current displayed values for panels of this site+type so the UI resets to the new date
          panelList.forEach(p => {
            const isSite = p.key.startsWith(site);
            const isType = (type === 'status') ? p.key.includes('status') : !p.key.includes('status');
            if (isSite && isType) {
              const s = panels[p.key];
              s.display = [];
              s.lastRowid = null;
              s.durationRaw = null;
              s.durationSec = null;
              s.windSpeed = null;
              s.windDir = null;
              s.nacelleDir = null;
              s.statusValue = null;
              s.statusClass = 'badge-default';
              // show spinner for data panels while waiting for the first matching record
              if (type === 'data') s.loading = true;
            }
          });
          // set the filter date for the site+type and reconnect with since_ms so the server can stream from that date
          const key = `${site}_${type}`;
          const dateVal = siteDates[key];
          const sinceMs = dateVal ? new Date(dateVal + 'T00:00:00').getTime() : null;
          // reconnect affected panels with optional since_ms
          panelList.forEach(p => {
            const isSite = p.key.startsWith(site);
            const isType = (type === 'status') ? p.key.includes('status') : !p.key.includes('status');
            if (isSite && isType) {
              try { createConnection(p.key, p.path, panels[p.key].waitSeconds, sinceMs); } catch(_){ }
            }
          });
        }

        function clearDate(site, type) {
          const key = `${site}_${type}`;
          siteDates[key] = null;
          // reconnect affected panels without since param so they stream normally; do not call applyDate (which would reconnect again)
          panelList.forEach(p => {
            const isSite = p.key.startsWith(site);
            const isType = (type === 'status') ? p.key.includes('status') : !p.key.includes('status');
            if (isSite && isType) {
              try { createConnection(p.key, p.path, panels[p.key].waitSeconds, null); } catch(_){ }
            }
          });
        }


        const visiblePanels = computed(() => {
          return panelList.filter(p => {
            if (activeSite.value === 'kelmarsh') return p.key.startsWith('kelmarsh');
            if (activeSite.value === 'penmanshiel') return p.key.startsWith('penmanshiel');
            return true;
          });
        });

        // Legacy variables kept for compatibility but not used for Kelmarsh anymore
        const overviewEnabled = ref(false);
        const overviewData = reactive({});
        const overviewES = {};
        const overviewReconnect = {};
        const statusData = reactive({});
        const statusES = {};
        const statusReconnect = {};

        const overviewTurbineRange = computed(() => {
          if (activeSite.value === 'kelmarsh') return Array.from({length: 6}, (_, i) => i+1);
          return Array.from({length: 15}, (_, i) => i+1);
        });

        // rot function for any SVG rotations (kept for compatibility)
        function rot(t, kind) {
          try {
            const v = overviewData[t] && overviewData[t][kind] != null ? Number(overviewData[t][kind]) : 0;
            if (!Number.isFinite(v)) return 'rotate(0 50 50)';
            return 'rotate(' + Math.round(v) + ' 50 50)';
          } catch (_) { return 'rotate(0 50 50)'; }
        }


        function applyPanel(panelKey, path) {
           // reconnect using the panel's waitSeconds and current turbine selection
          createConnection(panelKey, path, panels[panelKey].waitSeconds);
         }

        // add selectTurbine to immediately apply turbine selection
        function selectTurbine(panelKey, t, path) {
          panels[panelKey].turbine = (t === null ? null : t);
          // When switching turbines, prefer to continue from last seen timestamp for the site/type
          try {
            const site = panelKey.startsWith('kelmarsh') ? 'kelmarsh' : 'penmanshiel';
            const type = panelKey.toLowerCase().includes('status') ? 'status' : 'data';
            const siteKey = `${site}_${type}`;
            const since = lastSeenMs[siteKey] || (siteDates[siteKey] ? new Date(siteDates[siteKey] + 'T00:00:00').getTime() : null);
            // If we selected a turbine (not All) try to resolve a start_rowid on the server to avoid misses
            const meta = panelList.find(p => p.key === panelKey) || null;
            const source = meta && meta.byTurbine ? meta.byTurbine.split('/').filter(Boolean).pop() : null;
            if (t !== null && source) {
              const resolveUrl = new URL('/sse/resolve-rowid', location.origin === 'null' ? 'http://127.0.0.1:8000' : location.origin);
              resolveUrl.searchParams.set('source', source);
              resolveUrl.searchParams.set('turbine', String(t));
              if (since !== null) resolveUrl.searchParams.set('since_ms', String(Number(since)));
              fetch(resolveUrl.toString()).then(r => r.json()).then(js => {
                const rid = (js && js.rowid) ? js.rowid : null;
                if (rid !== null) {
                  createConnection(panelKey, path, panels[panelKey].waitSeconds, null, rid);
                } else {
                  // fallback to since_ms-based reconnect
                  createConnection(panelKey, path, panels[panelKey].waitSeconds, since);
                }
              }).catch(_=>{
                // on error fallback
                createConnection(panelKey, path, panels[panelKey].waitSeconds, since);
              });
            } else {
              // All selected or no source mapping, just reconnect with since
              createConnection(panelKey, path, panels[panelKey].waitSeconds, since);
            }
          } catch (_) { try { createConnection(panelKey, path, panels[panelKey].waitSeconds); } catch(_){} }
        }

         onMounted(() => {
           // open connections for all panels so inactive sites continue to receive updates in background
           panelList.forEach(p => {
            try { createConnection(p.key, p.path); } catch(_){ }
           });
          });

         onBeforeUnmount(() => {
           Object.keys(panels).forEach(k => { try { if (panels[k].es) panels[k].es.close(); } catch(_){} });
          // stop all turbine streams
          try { stopAllStreams(); } catch(_){}
         });

        return { panelList, panels, visiblePanels, activeSite, setSite, siteDates, applyDate, clearDate, applyPanel, selectTurbine, overviewTurbineRange, rot, turbineData, turbineStatus, turbineRange, siteStartDates, availableDates, dateLoading, onDateChange, clearStartDate };
      }
    }).mount('#app');
   </script>
 </body>
 </html>
